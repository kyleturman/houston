import Foundation

// MARK: - Feed Domain Model
//
// Purpose:
//   Represents AI-generated daily feed with personalized content including
//   notes, reflections, and discoveries. The feed is generated by
//   the backend agent based on user goals and activities.
//
// API Mapping:
//   Source: Backend /api/feed endpoint (Rails backend)
//   Key transforms:
//     - generated_at (ISO8601 String) → generatedAt (Date)
//     - duration_seconds (Int) → durationSeconds (Int)
//     - item_type (String) → decoded to FeedItemData enum
//     - snake_case → camelCase property names
//
// Usage:
//   - Home feed view (HomeView, FeedView)
//   - Feed generation monitoring
//
// Persistence:
//   - Codable for caching
//   - Custom FeedItemData decoder for polymorphic items
//
// Thread Safety:
//   - Struct (value type) safe for concurrent access

/// Feed response from backend
///
/// Simple collection of today's agent notes and insights.
/// Feed is just a filtered query - no "generation" concept.
///
/// **Lifecycle:**
/// 1. Backend queries today's agent notes + insights
/// 2. Sorted by display_order (weighted random)
/// 3. Returned as JSON from /api/feed/current
/// 4. Displayed in home view
///
/// **Example:**
/// ```swift
/// let response: FeedResponse = try decoder.decode(FeedResponse.self, from: data)
/// print("Feed for \(response.date): \(response.items.count) items")
/// ```
struct FeedResponse: Codable {
    /// Feed date (ISO8601 date string)
    let date: Date

    /// Feed content items (notes, reflections, discoveries)
    /// - Note: Pre-sorted by weighted-random display_order
    let items: [FeedItem]

    enum CodingKeys: String, CodingKey {
        case date
        case items
    }
}

/// Feed item with type and data
///
/// Wrapper for different types of feed content (notes, reflections, discoveries).
/// Items are pre-sorted by backend using weighted-random display_order.
///
/// **Item Types:**
/// - note: Agent-generated note about progress or insights
/// - reflection: Prompt for user reflection on goals
/// - discovery: External content discovery (articles, videos, etc.)
///
/// **Example:**
/// ```swift
/// let item = FeedItem(
///     id: "123",
///     itemType: "note",
///     data: .note(noteData)
/// )
/// ```
struct FeedItem: Codable, Identifiable {
    /// Unique identifier from backend
    let id: String

    /// Type of feed item ("note", "reflection", "discovery")
    /// - Note: Used for analytics and filtering
    let itemType: String

    /// Item content (polymorphic based on itemType)
    let data: FeedItemData

    enum CodingKeys: String, CodingKey {
        case id
        case itemType = "type"
        case data = "content"
    }
}

/// Polymorphic feed item data
///
/// Represents different types of feed content with type-safe enum.
/// Custom decoder tries each type until one succeeds.
///
/// **Decoding Strategy:**
/// 1. Try NoteData (has title, content, goalId)
/// 2. Try ReflectionData (has prompt, insightType)
/// 3. Try DiscoveryData (has title, summary, url)
/// 4. Fail if none match
///
/// **Example:**
/// ```swift
/// switch feedItem.data {
/// case .note(let note):
///     print(note.title)
/// case .reflection(let reflection):
///     print(reflection.prompt)
/// case .discovery(let discovery):
///     print(discovery.url)
/// }
/// ```
enum FeedItemData: Codable {
    /// Agent-generated note
    case note(NoteData)

    /// Reflection prompt for user
    case reflection(ReflectionData)

    /// External content discovery
    case discovery(DiscoveryData)

    /// Extract createdAt from underlying data if available
    var createdAt: Date? {
        switch self {
        case .note(let noteData):
            return noteData.createdAt
        case .reflection(let reflectionData):
            return reflectionData.createdAt
        case .discovery(let discoveryData):
            return discoveryData.createdAt
        }
    }

    /// Extract timePeriod from underlying data if available
    var timePeriod: String? {
        switch self {
        case .note(let noteData):
            return noteData.timePeriod
        case .reflection(let reflectionData):
            return reflectionData.timePeriod
        case .discovery(let discoveryData):
            return discoveryData.timePeriod
        }
    }
}

// MARK: - Time Period Grouping

/// Time periods for grouping feed items
enum FeedTimePeriod: String, CaseIterable {
    case morning = "Morning"
    case afternoon = "Afternoon"
    case evening = "Evening"

    /// Determine time period from a date (fallback when timePeriod string not available)
    static func from(date: Date) -> FeedTimePeriod {
        let hour = Calendar.current.component(.hour, from: date)
        switch hour {
        case 0..<12:
            return .morning
        case 12..<17:
            return .afternoon
        default:
            return .evening
        }
    }

    /// Parse time period from string (from backend API)
    static func from(string: String?) -> FeedTimePeriod? {
        guard let string = string?.lowercased() else { return nil }
        switch string {
        case "morning": return .morning
        case "afternoon": return .afternoon
        case "evening": return .evening
        default: return nil
        }
    }

    /// Sort order for displaying (most recent first: evening → afternoon → morning)
    var sortOrder: Int {
        switch self {
        case .evening: return 0
        case .afternoon: return 1
        case .morning: return 2
        }
    }

    /// SF Symbol icon for this time period
    var icon: String {
        switch self {
        case .morning: return "sun.horizon"
        case .afternoon: return "sun.max"
        case .evening: return "moon.stars"
        }
    }

    /// Contextual display title based on position in feed
    /// - Parameters:
    ///   - isNewest: Whether this is the first/most recent section
    ///   - sectionIndex: Position in the feed (0 = newest)
    ///   - totalSections: Total number of sections in the feed
    /// - Returns: A short contextual title
    func displayTitle(isNewest: Bool, sectionIndex: Int, totalSections: Int) -> String {
        switch self {
        case .evening:
            return "For you this evening"
        case .afternoon:
            if isNewest {
                return "Afternoon tidbits"
            } else {
                // Evening exists above
                return "From the afternoon"
            }
        case .morning:
            if isNewest {
                return "Fresh this morning"
            } else if totalSections == 2 {
                // Afternoon exists above (no evening)
                return "From the morning"
            } else {
                // Evening exists (3 sections)
                return "Earlier this morning"
            }
        }
    }
}

/// Group feed items by time period
struct FeedGroup: Identifiable {
    let id: FeedTimePeriod
    let period: FeedTimePeriod
    let items: [FeedItem]

    init(period: FeedTimePeriod, items: [FeedItem]) {
        self.id = period
        self.period = period
        self.items = items
    }
}

extension FeedResponse {
    /// Group feed items by time period (evening first, then afternoon, then morning)
    func groupedByTimePeriod() -> [FeedGroup] {
        // Group items by their time period
        var grouped: [FeedTimePeriod: [FeedItem]] = [:]

        for item in items {
            // Use timePeriod from backend if available, otherwise fall back to createdAt
            let period: FeedTimePeriod
            if let timePeriodString = item.data.timePeriod,
               let parsedPeriod = FeedTimePeriod.from(string: timePeriodString) {
                period = parsedPeriod
            } else {
                // Fallback: compute from createdAt or use current time
                let date = item.data.createdAt ?? Date()
                period = FeedTimePeriod.from(date: date)
            }

            if grouped[period] == nil {
                grouped[period] = []
            }
            grouped[period]?.append(item)
        }

        // Convert to FeedGroups and sort by period (evening first)
        return grouped
            .map { FeedGroup(period: $0.key, items: $0.value) }
            .sorted { $0.period.sortOrder < $1.period.sortOrder }
    }
}

// MARK: - FeedItemData Codable

extension FeedItemData {
    /// Custom decoder tries each type sequentially
    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()

        // Try to decode as different types based on structure
        if let noteData = try? container.decode(NoteData.self) {
            self = .note(noteData)
        } else if let reflectionData = try? container.decode(ReflectionData.self) {
            self = .reflection(reflectionData)
        } else if let discoveryData = try? container.decode(DiscoveryData.self) {
            self = .discovery(discoveryData)
        } else {
            throw DecodingError.dataCorruptedError(
                in: container,
                debugDescription: "Unknown feed item data type"
            )
        }
    }

    /// Custom encoder for polymorphic data
    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .note(let data):
            try container.encode(data)
        case .reflection(let data):
            try container.encode(data)
        case .discovery(let data):
            try container.encode(data)
        }
    }
}

/// Note content in feed
///
/// Agent-generated note about progress, insights, or observations.
/// Can be associated with a specific goal.
///
/// **Example:**
/// ```swift
/// let noteData = NoteData(
///     id: "123",
///     title: "Progress Update",
///     content: "You've completed 3 tasks this week!",
///     goalId: "456",
///     goalName: "Learn Swift"
/// )
/// ```
struct NoteData: Codable {
    /// Note identifier (may reference Notes table)
    let id: String

    /// Note title
    let title: String

    /// Note content/body
    let content: String

    /// Associated goal ID if applicable
    let goalId: String?

    /// Associated goal name for display
    let goalName: String?

    /// When the note was created
    let createdAt: Date?

    /// Time period this note belongs to (morning/afternoon/evening)
    let timePeriod: String?

    enum CodingKeys: String, CodingKey {
        case id
        case title
        case content
        case goalId = "goal_id"
        case goalName = "goal_name"
        case createdAt = "created_at"
        case timePeriod = "time_period"
    }
}

/// Reflection prompt in feed
///
/// Question or prompt for user self-reflection on their goals.
/// Can target specific goals or be general.
///
/// **Types:**
/// - progress: Reflect on progress made
/// - challenge: Consider obstacles faced
/// - planning: Think about next steps
/// - learning: Reflect on lessons learned
///
/// **Example:**
/// ```swift
/// let reflectionData = ReflectionData(
///     prompt: "What challenges did you face this week?",
///     goalIds: ["123", "456"],
///     insightType: "challenge"
/// )
/// ```
struct ReflectionData: Codable {
    /// Reflection question/prompt
    let prompt: String

    /// Associated goal IDs if applicable
    /// - Note: Can be nil for general reflections
    let goalIds: [String]?

    /// Type of insight being prompted
    /// - Note: Used for categorizing reflections
    let insightType: String?

    /// When the reflection was created
    let createdAt: Date?

    /// Time period this reflection belongs to (morning/afternoon/evening)
    let timePeriod: String?

    enum CodingKeys: String, CodingKey {
        case prompt
        case goalIds = "goal_ids"
        case insightType = "insight_type"
        case createdAt = "created_at"
        case timePeriod = "time_period"
    }
}

/// Discovery content in feed
///
/// External content (article, video, tool) discovered by agent
/// that's relevant to user's goals.
///
/// **Types:**
/// - article: Blog post or article
/// - video: Tutorial or talk
/// - tool: Software or service
/// - course: Learning resource
///
/// **Example:**
/// ```swift
/// let discoveryData = DiscoveryData(
///     title: "SwiftUI Best Practices",
///     summary: "Comprehensive guide to SwiftUI patterns",
///     url: "https://example.com/swiftui",
///     source: "Apple Documentation",
///     goalIds: ["123"],
///     discoveryType: "article"
/// )
/// ```
struct DiscoveryData: Codable {
    /// Content title
    let title: String

    /// Brief summary/description
    let summary: String

    /// URL to content
    let url: String

    /// Content source (website, platform, etc.)
    /// - Note: Optional as backend may not always provide source
    let source: String?

    /// OG image URL for preview
    /// - Note: Fetched from URL's Open Graph metadata
    let ogImage: String?

    /// Associated goal IDs
    /// - Note: Content relevant to these goals
    let goalIds: [String]?

    /// Type of discovered content
    /// - Note: Used for categorizing and filtering
    let discoveryType: String?

    /// When the discovery was created
    let createdAt: Date?

    /// Time period this discovery belongs to (morning/afternoon/evening)
    let timePeriod: String?

    enum CodingKeys: String, CodingKey {
        case title
        case summary
        case url
        case source
        case ogImage = "og_image"
        case goalIds = "goal_ids"
        case discoveryType = "discovery_type"
        case createdAt = "created_at"
        case timePeriod = "time_period"
    }
}

// MARK: - Feed Schedule

/// Feed schedule response
///
/// Shows per-period schedule settings for feed insight generation.
/// Feed insights are generated up to 3x/day (morning, afternoon, evening) based on user's timezone.
/// Each period can be enabled/disabled and have a custom time.
///
/// **Example:**
/// ```swift
/// let schedule: FeedSchedule = try decoder.decode(FeedSchedule.self, from: data)
/// if let morning = schedule.periods["morning"], morning.enabled {
///     print("Morning feed at \(morning.time)")
/// }
/// ```
struct FeedSchedule: Codable {
    /// Per-period configuration (morning, afternoon, evening)
    let periods: [String: FeedPeriodConfig]

    /// User's timezone (e.g., "America/Los_Angeles")
    let timezone: String

    /// Get enabled periods sorted by time
    var enabledPeriods: [(period: String, config: FeedPeriodConfig)] {
        let order = ["morning", "afternoon", "evening"]
        return order.compactMap { period in
            guard let config = periods[period], config.enabled else { return nil }
            return (period: period, config: config)
        }
    }

    /// Get hour for a period (parses "HH:00" format)
    func hour(for period: String) -> Int? {
        guard let config = periods[period] else { return nil }
        let components = config.time.split(separator: ":")
        guard let hourStr = components.first else { return nil }
        return Int(hourStr)
    }
}

/// Configuration for a single feed period
///
/// **Example:**
/// ```swift
/// let config = FeedPeriodConfig(
///     enabled: true,
///     time: "06:00",
///     nextRun: Date()
/// )
/// ```
struct FeedPeriodConfig: Codable {
    /// Whether this period is enabled
    let enabled: Bool

    /// Scheduled time in HH:00 format (e.g., "06:00", "12:00", "17:00")
    let time: String

    /// Next scheduled run time (nil if disabled or not scheduled)
    let nextRun: Date?

    enum CodingKeys: String, CodingKey {
        case enabled
        case time
        case nextRun = "next_run"
    }
}
